0407 업무일지
- 터미널에서 git status 했을때 
On branch signin
nothing to commit, working tree clean - 현재 프로젝트가 최신의 버전이라는 뜻
-----------------------------------------------------------------------------------------
로그인 브랜치 병합

-터미널에서 git status / git add . / git status / git commit -m '로그인페이지 완성' / git status / git push origi signin (푸쉬한다. origi signin을)
github에서 브랜치 항목에 signin 브랜치 확인
Netify에서 site overview에서 사이트 확인
               site settings에서 build & deploy에서 deploy contexts에서 productio branch: master확인
github에서 pull requests에서 New pull request 

로그인 페이지를 만들고 브랜치 설정 후
깃허브에서 signin branch와  메인index. 즉 master브랜치와 병합한다.
 pull requests - create pull request - base : 합쳐질 기존 master 브랜치 compare: 새로 만든 브랜치 합쳐야하는 브랜치 클릭 후 
create pull request 클릭, create pull request 클릭, merge pull request 클릭, merge confirm 클릭,

터미널을 이용해서 프로젝트선택 및 복제폴더할 수있다.
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

새로운 크로스 플랫폼 PowerShell 사용 https://aka.ms/pscore6
- 폴더 목록 정보 확인
PS C:\Users\YoureeChoi\Desktop\yull>  dir 
-디렉토리 변경
PS C:\Users\YoureeChoi\Desktop\yull>  cd desk하고 탭하면 ( 데스크탑으로 접근한다.폴더명이 자동완성됨)

*데스크탑이 아닌 전의 위치로 빠져나가고 싶으면 cd ..하고 엔터 하면 빠져나오기 가능

PS C:\Users\YoureeChoi\Desktop>git clone https://github.com/choiyouree/yull.git(주소) - 복제해준다.
다시 dir 을 해주면ㅍ 폴더 생성 되어져 있다.

--------------------------------------
되돌리기
PS C:\Users\YoureeChoi\Desktop\youree\0407_git-practice> git reset --hard HEAD~1 (head에서 한번 전에 것으로 되돌리겟다. 현재에서 전에것으로 )
되돌리기를 했는데 다시 원상복구 할때
PS C:\Users\YoureeChoi\Desktop\youree\0407_git-practice> git reset --hard ORIG_HEAD

---------------------------------------------
Mark Down 마크다운
장점: 문법이 쉽고 간결하다 , 관리가 쉽다 , 지원가능한 플랫폼과 프로그램이 다양하다
단점: 모든html 마크업을 대신하지 못한다.

README.me 대문자 입력하는 이유
github에 원격 저장소에서 readme를 찾게 설정되어있다.

#의 갯수로 h1~h6까지 설정 할 수 있다. ( ex. # 제목 1 - <h1>제목 1 </h1> )

줄바꿈처리- <br> or 띄어쓰기 두번

강조처리 - 이텔릭(_이텔릭_) 두껍게(**두껍게**) 이텔릭두껍게 (**_이텔릭두껍게_**) 취소선 (~~취소선~~) 밑줄  (<u>밑줄</u>)

# 목록(List)
1. 순서가 필요한 목록  
     1.순서가 필요한 목록  
     1.순서가 필요한 목록
1. 순서가 필요한 목록
1. 순서가 필요한 목록
<!-- 직접 순서를 넣지 않아도 자동으로 만들어짐 -->
<!-- 들여쓰기 두번하면 소제목을 넣듯이 작은 내용 넣을 수 있음 -->
- 순서가 필요하지 않은 목록  
    - 순서가 필요하지 않은 목록
- 순서가 필요하지 않은 목록
- 순서가 필요하지 않은 목록
<!-- 하이픈 점 기호로 목록을 나타내는 -->
<!-- 들여쓰기 2번 하이픈 점기호로 소제목 넣듯 작은 내용 넣을 수 있음 -->

# 링크(Link)

<a href="http://google.com">GOOGLE</a>  
[GOOGLE](http://google.com)  
<a href="http://naver.com">NAVER</a>   
[NAVER](http://naver.com "NAVER로 이동!")

# 이미지 (Image)

![HEROPY](https://heropy.blog/css/images/logo.png)

<!-- 이미지에 링크되게 -->
[![HEROPY](https://heropy.blog/css/images/logo.png)](https://heropy.blog/)

# 인용문(BlockQuote)

>남의 말이나 글에서 직접 또는  
>간접으로 따온 문장.(네이버 국어 사전)

>인용문을 작성하세요!
>> 중첩된 인용문
>>> 중중첩된 인용문 1
>>> 중중첩된 인용문 2
>>> 중중첩된 인용문 3

# 인라인(inline) 코드 강조

css에서 `background` 혹은  
`background-image` 속성으로   
요소에 배경 이미지를 삽입할 수 있습니다.

# 블록(block) 코드 강조

```html
<a href="http://www.google.co.kr/" target="_blank">GOOGLE</a>
```
```css
.list > li {
  positon: absolute;
  top: 20px;
}
```
----------------------------------------------------------------------------------------------------------------------------------------04.07---------
터미널을 열어 명령하면 node.js 설치를 하고 nvm 설치로 node 버전을 선택해서 사용할 수 있다.


node moduls 폴더에서 삭제가 되어도 이미 삭제한 모듈이 명시되어져 있는 모듈을 한번에 설치가 된다. npm i
즉, 설치한 패키지는 내역으로 남게되고 그 내역을 바탕으로 지우더라도 npm install 이나 npm if를 통해서 해당하는 패키지를 설치가능하다.

packagelock.json은 package-json의 내부에서 사용되는 패키지의 정보가 lock에 들어가게된다 자동으로 관리되는 파일. json 파일은 삭제되면 안되는 파일. 주의해야함

devDependencies:parcel-bundler는 installl -d
dependencies:lodash는 install

console.log(_.camelCase('hello world'));
// 콘솔에 hello world를 카멜케이스 문법으로 반환한다.

parcel 같은 모듈,패키지가 들어가 있는node_modules는 삭제하더라도 npm install 명령하면 다운로드 된다. 단 package.json에 버전이 명시되어 있어야한다.
"devDependencies": {
    "parcel-bundler": "^1.12.4"
  },
  "dependencies": {
    "lodash": "^4.17.20"

ECMA스크립트..에크마스크립타.. ES라고도 불른다
 ㄴ 자바스크립트의 표준화된 명칭... version


프론트 엔드 개발에서는 내부에 로컬서버를 별도로 오픈해서 작업한다. npm run dev
오른쪽 버튼의 오픈 라이브 서버 X

----------------------------------------------------------------------------------------------------------------
**데이터 타입 확인

console.log(typeof 'hello world!'); - string
console.log(typeof 123); - number
console.log(typeof true) - boolean
console.log(typeof undefined) - underfined
console.log(typeof null) - object

------------------------------------------------------------------------------------------------------------------
**산술 연산자

console.log(1 + 2);  -3
console.log(3 - 1);   --2
console.log(3 * 3);   -9
console.log(10 / 2)  -5

나머지 연산자
console.log(7 % 5 )  -2

-------------------------------------------------------------------------
**할당 연산자

let  a = 2 ( const는 재할당 불가하기 때문에 let으로 )
 a = a + 1 ㄱ
 a += 1     」 둘다 같은 뜻의 코드.

console.log(a)   -3
-----------------------------------------------------------------------------
**비교 연산자

const a = 1
const b = 1
 
console.log( a === b )     -true (값도 일치 데이터타입도 일치하기 때문에 true)===이꼴기호 3개는 둘다 정확히 일치해야지 true 값!  
                    일치연산자
만약에  const a = 1 const b ='2' console.log( a ===b )  -false

------------------------------------------------------------------------------------
function isEqual(x, y) {
  return x === y             -false
}
console.log(isEqual(1, 3))
//isEqual 이란 함수에 매개변수 각 x, y 가 있다. 그것을 반환할것이다 일치연산자 x == y , 즉 1,3 이 일치한가?
// 콘솔에 띄울것이다. 일치하지 않기에 false가 나온다.
-------------------------------------------------------------------------------------
(!== 는 서로 다른 것을 확인해주는 연산자, 즉 불일치 연산자)
const a = 1
const b = 3
        
console.log(a !== b) 같지 않다 ? true (서로 다른것이 사실이기때문에)       
console.log(a < b) 1보다 3이 더 크다 ? true

const c = 5
const d = 5

console.log(5 <= 5) 같거나 크다 true ( 이퀄기호 = 는 항상 꺽새가로 <  뒤에 가도록 해야함)
--------------------------------------------------------------------------
**논리연산자

const a = 1 ===1
const b = 'AB' === 'AB'
const c = false

console.log(a)
console.log(b)
console.log(c)
----------------------------------------------------------------------
** 또다른 논리 연산자 
console.log ('&&: ', a &&, b &&, c )   -&&false
              ''작은 따옴표 안에는 문자데이터로 읽는다
	a와 b와 c는 같은가? 
	하나라도 맞지 않은면 false

console.log('||: ', a || b || c)
	또는 or 
	하나이상의 true가 있으면 true 
console.log('!: ', !a)
               !는 부정의 뜻
	a는 true 부정하면 false
------------------------------------------------------------
**삼항 연산자

const a = 1 < 2

if (a) {
  console.log('참')
} else {
  console.log('참')
}



같은 뜻의  코드

console.log(a ? '맞아' : '아니야')
1<2은 참이다. 참이면 콘솔에 맞아라고 입력하고 거짓이면 아니야라고 입력하라.
------------------------------------------------------------

**조건문 
브라우저 개발자도구에 콘솔창에 
랜덤한 함수 소수점 단위로 나타나게 Math.random() 
랜덤한 함수 소수점 단위 빼고 정수로 나타나게Math.floor(Math.random() * 10) 

export default function random() {
  return Math.floor(Math.random() * 10)
} 
export default로 random 이란 함수를 파일 밖으로도 반환할 수 있다.

다른 파일에서 함수를 끌어들여서 사용할 수 있다
import random from './getRandom'
--------------------------------------------------------------------------------------------
** 조건문 if else문

const a = random()

if (a === 0) {
  console.log('a is 0')
} else if (a === 2) {
  console.log('a is 둘')
} else {
  console.log('b is 0')
}
제가 만든 랜덤한 정수의 숫자들이 0이면 a is 0 2면 a is 둘 그 외 다른 숫자 이면 b is 0
-----------------------------------------------------------------------------------------------------
** 조건문 switch문

switch (a) {
  case 0:
    console.log('눈눈누나는 0이야')
    break
  case 2:
    console.log('안녕나는 둘이야')
    break
  case 4:
    console.log('랄라라 4444')
    break
  default:
     console.log('rest...')
}
케이스의 내용을 언급해서 해당하는 내용이 나오게 .. case 설정후 다른 내용들과 섞이지 않게 break
-----------------------------------------------------------------------------------------------------------------------04.11--------------------------------------------------------------------------------------------------------


 [변수 유효범위, 형 변환, 함수 복습...(호이스팅, 타이머, 콜백),자바스크립트 데이터]
**반복문 for ( 시작조건;  종료조건;  변화조건) {}
for ( lef i
조건 중간에 세미콜론(;) 이 있고 마지막엔 붙지 않는다.

a === b 일치연산자 a == b 동등연산자
-------------------------------------------------------------------------

**변수 유효범위
** 함수를 지정 후 ,  움직이는 값을 입력해야한다. 순서가 엇갈리거나 {} 괄호 안에 들어가 있지 않으면 오류!
--------------------------------------------------------------------------------
** 형변환

truthy(참 같은 값)
true, {}, [], 1, 2, '', -12, '3.14' ...

falsy (거짓 같은 값)
false, '', null, undefined, 0, -0, NaN

----------------------------------------------
** 자바스크립트 함수 복습 **

** 화살표 함수 - 함수를 축약형으로 최소화 할 수 있다.
fuction을 지우고 {} 앞에 => 을 넣는다.
// () => {} vs function () {}
 
const double = function (x) {
  return x * 2
}
console.log('double :', doubel(7))
                 =동일한 코드 
const doubelArrow = (x) => {
  return x * 2
}
console.log('doubleArrow', doubleArrow(7))
----------------------------------------------
**즉시실행 함수  - IIFE

const a = 7
function doubel() {
  console.log(a * 2)
}
doubel();

(function () {
  console.log(a * 2)
})
---------------------------------------------------------------------------------------------
**호이스팅(hoistiong)- 함수 선언부가 유효범위 최상단으로 끌어올려지는 현상
코드를 위에서 부터 아래로 읽어내려갈때 변수,함수,이름이 실행되는 것을 유추하기 쉽다.

전에 배웠던 코드
const a = 7

const double = function () {
  console.log(a * 2)
}

호이스팅방법으로 바꾼 코드
const a = 7

double()

function double() {
  console.log(a * 2)
}
-------------------------------------------------------------------------------------------------
** 타이머 함수 - 1000ms = 1s
// setTimeout(함수, 시간): 일정 시간 후 함수 실행
// setInterval(함수, 시간): 시간 간격마다 함수 실행
// clearTimeout(): 설정된 Timeout 함수를 종료
// clearInterval(): 설정된 Interval 함수를 종료

const timer = setInterval( () => {
  console.log('youree!')
}, 3000)

const h1El = document.querySelector('h1')
h1El.addEventListener('click', () => {
  clearInterval(timer)
});
--------------------------------------------------------------------------------
** 콜백 (함수의 인수로 사용되는 또다른 함수) - 실행 위치를 보장하는 용도로 많이 활용됨.
// setTimeout(함수, 시간)

function timeout(callback) {
  setTimeout(() => {
    console.log('youree')
    callback()
  }, 3000)
}
timeout(() => {
  console.log('done')
  clearTimeout
},4000)
------------------------------------------------------------------------------------------------
**this
// 일반 (normal) 함수는 호출위치에서 따라 this 정의!
// 화살표 (arrow) 함수는 자신이 선언된 함수 범위에서 this 정의!

const heropy = {
  name: 'heropy',
  normal: function () {          -heropy
    console.log(this.name)     -undefined
  },
  arrow: () => {
    console.log(this.name)
  }
}
heropy.normal()
heropy.arrow()

const amy = {
  name: 'Amy',
  normal: heropy.normal,     -amy
  arrow: heropy.arrow          -undefined
}
amy.normal()
amy.arrow(
----------------------------------------------------------------------------------------------------------------
** Es6 classes - 새로운 문법 간결하고 직관적이고 유연하게 코딩할 수 있다.

- 축약 전의 코드
// function User(first, last) {
//   this.firstName = first
//   this.lastName = last
// }
// User.prototype.getFullName = function () {
//   return `${this.firstName} ${this.lastName}`
// }

-축약 후의 코드
class User {
  constructor(first, last) {
    this.firstName = first
    this.lastName = last
  }
  getFullName() {
    return `${this.firstName} ${this.lastName}`
  }
}

const heropy = new User('heropy', 'park')
const amy = new User('Amy', 'Clarke')
const neo = new User('Neo', 'Smith')

console.log(heropy)
console.log(amy.getFullName())
console.log(neo.getFullName())
-----------------------------------------------------------------------------------------------------------------
**숫자와 수학
console.log('abs: ', Math.abs(-12))

console.log('min: ', Math.min(2, 8))

abs : -를 정수로 바꿔줌
min : 제일 작은 숫자
max : 제일 큰  숫자
celi : 올림 된 숫자
floor : 내림 된 숫자
round : 반올림이나 반내림
random : 랜덤 숫자


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   4.12  -----------------------------------------
pat.4) 05.객체 ~ 

// .splice() - 원본 수정됨 주의

const numbers = [1, 2, 3, 4]
const fruits = ['Apple', 'Banana', 'Cherry']

numbers.splice(2, 1, 99) - 제로베이스의 2번째 (인덱스) 의 1개를 제거하고 그 자리에 99를 넣는다.
 
console.log(numbers) - 콘솔에 띄어지는 결과 1, 2, 99, 4

fruits.splice(2, 0, 'Orange') - 2번째의 0개를 제거하고 그 자리에 orange를 넣는다

console.log(fruits) - Apple, Banana,  Orange ,Cherry

----------------------------------------------------------------------------------------------------------------

**객체
- object mdn

// object.assign() - 하나 이상의 출처 객체로 부터 대상객체로 속성을 복사 한다.
// target- 대상객체 , sources- 하나이상의 출처객체 // 출처객체가 대상객체에 더해진다.

const target = { a: 1, b: 2};
const source = { b: 4, c: 5}

const returndTarget = Object.assign(target, source);

console.log(target); - 1,4,5

console.log(returndTarget); - 1,4,5   b의 값은 중복 될 수 없어 덮어져서 출처객체의 4가 나타난다.

----------------------------------------------------------------------------------------------------------------------

const user = {
  name : 'heropy',
  age : 85,
  email : 'thesecond@gmail.com'
}

const keys = Object.keys(user)
console.log(keys)    // (3) ['name', 'age', 'email'] 출력

console.log(user.email)        ----
console.log(user['email'])   ------- 두개다 같은 값으로 나온다.

const values = keys.map(key => user[key])      -[ ] 으로 콜백하고 그 값이 나오게 설정가능하다.
console.log(values)   ---(3) ['heropy', 85, 'thesecond@gmail.com'] 출력

-----------------------------------------------------------------------------------------------------------------------

// 구조 분해 할당(비구조화 할당) - 함수를 쪼개서 정보를 보관해놓고 출력되도록

const user = {
  name: 'youree',
  age: 29,
  email: 'thesecon@gmail.com'
}
const { name, age, email, address = 'korea' } = user
// 함수에 지정한 속성들을 쪼개서 보관해줌

console.log(`제이름은 ${name}입니다.`)
console.log(`${name}의 나이는 ${age}세 입니다.`)
console.log(`${name}의 이메일은 ${user.email}입니다.`)
console.log(address)

const fruits = ['Apple', 'Banana', 'Cherry']
const [a, b, c, d] = fruits
console.log(a, b, c, d)
// 각자의 데이터 구조분해하는 데이터 타입에 맞게 기호를 적용한다.
------------------------------------------------------------------------------------------------------------------------------

**데이터 불변성 
원시데이터 : string, number, boolean, undefined, null - 기존에 원시 데이터들은 변하지 않는 성질을 가지고 있다.
참조형데이터 : object, array, function - 서로 똑같애도 같은 데이터가 아닐수도 있다.
----------------------------------------------------------------------------------------------------------------------------------

* (와일드카드) 여러내용을 한거번에 지정할 목적으로 사용하는 기호 

-----------------------------------------------------------------------------------------------------------------------------------------------------------------4.13----------------------------------------------------------

part.4 04 storage ~ part.5 02 Typescript 설치 및 사용 학습완료

자바스크립트 storage, 정규표현식, TypeScript


**json (javascript object notation) - 하나의 문자데이터
속성 값 쌍 /  키 값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 
-문자열은 큰 따옴표만 가능.
-객체 데이터 string,number,boolean,null,object,array를 활용할 수 있다. -main.js에서 불러서 사용할 수 있다.(Export myData from './myData.json')

**터미널 - npm init -y 하면 package.json 파일 만들어짐

**storage - 데이터를 저장해 놓는 곳 
localStorage.setItem('user',JSON.stringify(user))
user이란 key에 JSON.strigify: object Object.가 아니라 문자로 바꾸어준다. 

console.log(JSON.parse(localStorage.getItem('user'))) - JSON.parse 단순한 문자가 아니라 자바스크립트에 데이터로 바꾸어준다.
localStorage.removeItem('user')- 로컬 스토리지에서 저장한 데이터를 삭제한다.
반영구적으로 저장되기때문에 삭제한다는 코드를 넣지 않으면, 저장하는 코드를 지우더라고 삭제되지 않는다.

--------------------------------------------------------------------------------------------------------------
**영화정보를 활용할 수 있는 omdbapi
http://www.omdbapi.com/?apikey=[yourkey]& 에서 apikey 인증을 받아서 yourkey입력해야한다.

여기서 나오는 사이사이에 ?와 &은 쿼리 스트링(query string)이라고 한다. 문자를 가지고 뭔가를 검색한다는 개념
주소?속성=값&속상=값&속성=값 /특정한 주소 부분에 모음과기호 부분이 쿼리스트링. 옵션을 명시하는 형태

*프로젝트에서 영화정보로 인증할때 http를 https로 바꾸어준다.

**터미널에서 npm i axious 로 설치하기 -일반의존성

import axios from "axios";  //axios 가져오기

function fetchMovies() { //함수선언
  axios
    .get('https://www.omdbapi.com/?apikey=7035c60c&s=frozen') //얻어서
    .then( (response) => {    // 처리한다. response응답
      console.log(response)
    })
}
fetchMovies() // 함수 실행

--------------------------------------------------------------------------------------------------------------------------
**정규표현식 - 문자를 검색하고 대체하고 추출하는 기능 , 여러가지 특수기호 사용해서 어렵게 느껴질 수 있다.


** 개발서버 오픈 
폴더생성 후 오픈폴더 설정 - npm init -y ; pakage.json파일생성됨 - npm i parcel-bundler -D 개발하는 용도로 node_modules 폴더 생성됨 
- package.json 파일에서 script 부분에 test 영역 지운후 "dev": "parcel index.html"   "build": "parcel build index.html" 추가함 - 터미널에 npm run dev
(만약 Invalid version: undefine 이라고 나온다면 parcel-bundler버전의 문제기 때문에 ctrl + c / npm i parcel-bundler@1.12.3 -D



@@@@@@ part.4 정규표현식 복습 꼬오오옥 필요.... 




-----------------------------------------------------------------------------------------------------------------------

** 타입스크립트 (TypeScript) -타입스트립트컴파일러 사용. 우리가 사용하는 자바스크립트의 타입이란 개념을 적용시킨 것
프로그래밍언어.. Transpile...  Interpereted Language - 타입스크립트는 자바스크립트가 읽을 수 있게 다시 컴파일 해야한다.

타입스크립트 설치 = npm i typescript -g

------------------------------------------------------------------------------------------------------------------------------------------  4.14 ---------------------------------
** 타입스크립트 (TypeScript) -타입스트립트컴파일러 사용. 우리가 사용하는 자바스크립트의 타입이란 개념을 적용시킨 것
프로그래밍언어.. Transpile...  Interpereted Language

타입스크립트 설치 = npm i typescript -g
타입스크립트  파일 생성 = nano test.ts
타입스크립트 컴파일러 사용하는 명령어 - tsc test.ts  (파일 컴파일 하겠다)

**cd 폴더이름 - 폴더 안으로 들어가서 작업하겠다.
**어떤식으로 컴파일할건지 설정파일을 넣어줘야한다. 자동으로 생성하는 명령어 - tsc --init 
** tsc -- init : tsconfig.json 파일 만들기
**ls - 무슨 파일을 언제 컴파일 했는지 확인할수있게 리스트 되어 보여준다.
**tsc -w -(wathch모드)매번 tsc할 일없이파일이 수정 됬을때 마다 컴파일 된다


타입스크립트 중간 중간 진행이 끊겨서 (설명이해가 어렵고, 맥 os사용하셔서 작동방법이 다르고 윈도우os 방법 안나와있어.. 진행 어려움...)
다르게 학습할 수 있는 방법 찾아보거나 다른 파트 학습 후에 학습 진행 하겠습니다.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
part6.SCSS

**scss (css를 좀더 쉽게 사용하기 위한 강력한 도구,  css 전처리 도구)
CSS가 동작하기 전에 사용하는 기능으로,
웹에서는 분명 CSS가 동작하지만 우리는 CSS의 불편함을 이런 확장 기능으로 상쇄할 수 있습니다.

sass나 scss로 웹으로 보여지게 할려면 컴파일(변환)해야한다. (sass문법을 css로 동작하기전에 바꿔줘야한다는 뜻)

header .main-menu .item .item__contents .contents__menu {...} 이런식으로 선택자 길게 입력해야 되는 css였는데 sass에 중첩기능으로 쉽게 쓸 수 있다.
색상들도 함수로 지정해서 한번에 제어할 수 있고 손쉽게 통일할 수 있다.

**scss 의 중첩기능 
$color: royalblue;

.container {  - 괄호 안에 괄호를 넣어 다소 짧고 간결하게 코딩
  h1 {
    color: $color;
  }
}

**주석 사용시 주의사항!!
scss에서 css로 컴파일(변환) 될때 /*.....*/ 을 사용해야, 컴파일 됬을때 주석이 사라지지않고 잘 보이게 된다.
( scss - /**/, // 둘다 주석 처리 가능 )


**가상선택자를 쓸 때, 
css                     ------------>   scss
.btn {                                     .btn {
       positon: absolute;                  position:absolute;
}                                                &.active {
.btn.active {                                       color: red;
	color: red;                     }
}                                             }

**마진,패딩,폰트 속성 쓸 때,
css                  ----------------->   scss
.box {                                       .box {
   font-weight: bold;                       font: {
   font-size: 10px;                               weight: bold;
   font-family: sans-serif;                      size: 10px;
   margin-top: 20px;		            family: sans-serif;
   padding-bottom: 40px;                  };
}                                                   margin: { ......

**함수를 이용한 수정. 통일 가능
scss에서 $color: red;라고 선언후에 - color: $color;라고 하면 여러군데 통일성 있게 설정가능.
           자식요소 괄호 안에서 $color:blue 재할당해서 바꿀 수 있다. 하지만 그 뒤에 모든$color:blue, (괄호 안에서 설정하기는 했어도, 함수로 재할당 되었기 때문)

 **재활용 scss (mixins)
@mixin center { dispaly: flex; justify-content: center, align-items:center; } 라고 공통의 값을 적용할 때 mixin의 내용을 재활용 할 수 있게
.container { @include center; 이렇게 받아지는 함수도 같이 적용해야한다.

-------------------------------------------------------------------------------------------------------------------------------------
**SCSS 반복문을 학습을 위한 css/javacript 복습
-코드
for (let i = 0; i < 10; i += 1) {
  console.log('loop-${i}')
}
// for ( 시작, 종료, 반복 )재할당 할수있는 함수 i는 0이다 ,i는 10보다 작다, 0~9은 10보다 작다, 그런데 0~9를 1씩 더하면 9는 10이 된다.. 고로 0,1,2,3,4,5,6,7,8,9
// 콘솔  로그에 띄우겠습니다 내용은 loop-
console.log('hello')
-결과 콘솔에
"loop-0", "loop-1", "loop-2", "loop-3", "loop-4", "loop-5", "loop-6", "loop-7", "loop-8", "loop-9"

--------------------------------------------------------------------------------------------------------------------------------
@for $i from 1 through 10 {
        .box:nth-child(#{$i}) {                          -box 괄호 안에 1~10:nthchild 선택 가능 내용도 10번 반복됨
	width: 100px;
        }
}
-----------------------------------------------------------------------------------------------------------------------
**보간 - 인접한 데이터 점에 적합한 함수를 조각을 맞추어 데이터 중간값을 찾는 프로세스  

** 색상내장함수 
.box {
    $color: royalblue;
    width:200px;
    height: 100px;
     margin: 20px;
    border-radius: 10px;
    background-color : $color;
    $.built-in {
       background-color: darken($color, 10%);  -  10% 더 어두워진다 . lighten밝게/saturate채도가밝게/desaturate채도가떨어지게/grayscale(인수필요없음)/invert색상반전/rgba(함수, 투명도)
    }
}

**scss에서의 rgba는 rgba(색상, 투명도)만 설정해도 가능하다.

**npm 버전관리, 브라우저 띄우기 , css를 scss로 바꾸기
1. 새창에 폴더 선택 
2. npm init -y ( 버전관리 시작하겠다)
3. npm i -D parcel-bundler ( 개발자모드로 파슬 번들러 다운로드)
4. node moduels, package.json 파일 확인하기
5. package.json파일에 "script"부분 지운후 "dev" : "parcel index.html" "build" : "parcel build index.html"이라고 넣기
6. npm run dev
7. main.css 를 scss로 고치기
8. scss파일을 scss문법으로 바꾸기- 화면의 출력되는 결과는 바꾸지 않음

**리팩토링(Refactoring)은 '결과의 변경 없이 코드의 구조를 재조정함'을 뜻합니다. 코드만 수정하고 결과는 바뀌지 않음

-------------------------------------------------------------------------------------------------------------------------------------------------------------
part7.css프레임워크

**부트스트랩bootstrap - 웹사이트를 쉽게 만들 수 있게 도와주는 기능. 제작유지보수를 쉽게 할 수 있도록 한다.
버튼이나 드롭메뉴를 따로 css로 만들지 않아도 구조 안에서 해결 가능하다.

**트리쉐이킹 - 단일 번들을 최적화할 때 사용되는 필요하지 않은 코드를 제거하는 기술 

**부트스트랩 css - link 태그로 원격으로 연결할 수 있다
                  js -bundle : 부트스트랩에 popper.js가 포함되어 묶여있다.
	    js separate : 부트스트랩과 popper. js를 따로 넣을 때 popper위 상단에 먼저 호출, bootstrap 하단에 위치하도록 한다 

**popper.js ???
  팝업이 뷰포트 상자안에 가려지지  않도록 하거나,  팝업기능을 조금 더 쉽게 만들어주는 자바스크립

-------------------------------------------------------------------------------------------------------------------------  4.18  ------------------------------------------

part6. 타입스립트. - 자바스크립트보다 더 편리하게 오류를 수정하게끔 도와준다.

**nano test.ts 새로운 타입스크립트 파일 새성
tsc test.ts 타입스크립트 변환하기
get test.ts 
get test.js
mkdir tsc-project 프로젝트 파일 안으로 들어가기 전 , 폴더 만든다.
cd tsc-project 파일안으로 들어간다.

code . - vs code 실행

npm i typescript -D  (D)는 개발용 모듈이다

**Type Annotation 타입이 지정되고 그 안에 들어가는 타입도 그에 맞는 타입이 들어가야한다.
let a: number;

// a = "Mark";

a = 39;

function hello(b: number) {

}

hello(33);
--------------------------------------------------------------------------------------------------------
typescript = static Types 개발하는 중간에 타입을 체크한다
javascript = Dynamic Types 개발할땐 알 수 없고 런타임에 돌입해야지 오류를 알 수 있다.
----------------------------------------------------------------------------------------------------------
javaScript 기본자료형을 포함 (superset)
 - 에크마 스크립트 표준에 다른 기본 자료형은 6가지
	Boolean Number String Null Undefined Symbol(에크마 스크립트 6에 추가 ) Array:object형
 - 프로그래밍을 도울 몇가지 타입이 더 제공된다.
	Any, Void, Never, Unknown, Enum, Tuple:object형 

------------------------------------------------------------------------------------------------------------
null
-null이라는 값으로 할당된 것을 null이라고 한다.
-무언가가있는데 사용할 준비가 덜 된 상태.
-null 이라는 타입은 null이라는 값만 가질 수 있다.
-런타임에서 typeof연산자를 이용해서 알아내면, object입니다.
----------------------------------------------------------------------------------------------------------
undefined
-값을 할당하지 않은 변수는 undefined 라는 값을 가집니다.
-무언가가 아예 준비가 안된 상태
-object의 property가 없을때도 undefined 입니다.
-런타임에서 typeof연산자를 이용해서 알아내면, undefined입니다.
-----------------------------------------------------------------------------------------------------------------
tsconfig.json에서 compilerOptions ... 밑에 
"compileOnSave": true, -저장하면 자동으로 컴파일 된다.
--------------------------------------------------------------------------------------------------
**compileoptions

*target - 빌드의 결과물을 어떤 버전으로 할것인가. 지정을 안하면 es3버전
*lib - 기본type definition라이브러리를 어떤것을 사용할 것인가

---------------------------------------------------------------------------------------------------------------------------------------------4.19--------------------------------
 Part 5. TypeScript Essentials ch. 05 interface 02. optional property (1) ~

** interface - 타입을 만들어내는 방식
 - ex ) interfae User {
	name: string;
	readonly age: number;
           }

           let user : User = {
	name : 'XX',
	age : 30
           }

           user.age = 10; -err
           user.gender = "male" - err

           console.log(user.age)

**readonly - 읽기전용속성이기때문에 수정할 수 없다. 최초 생성 할당만 가능 이후 수정 불가
**typescript classes

object를 만드는 blueprint(청사진, 설계도)
클래스 이전에 object를 만드는 기본적인 방법은 function
javascript에도 class는 es6부터 사용가능
oop을 위한 초석
typescript에서는 클래스도 사용자가 만드는 타입의 하나

=====================================================================================================

생성자함수가 없으면, 디폴트 생성자가 불린다.
프로그래머가 만든 생성자가 하나라도 있으면, 디폴트 생성자 사라진다.
strict모드에서는 프로퍼티를 선언하는 곳 또는 생성자에서 값을 할당해야한다.
프로퍼티를 선언하는 곳 또는 생성자에서 값을 할당하지 않는 경우 !를 붙여서 위험을 표현한다.
클래스의 프로퍼티가 정의되어 있지만 값을 대입하지 않으면 undefined이다.
생성자는 async를 설정할 수 없다.

---------------------------------------------------------------------------------------------------------------------------

접근제어자에는 public, private, protected 가  있다.
설정하지 않으면 public이다
클래스 내부의 모든  곳에 (생성자, 프로퍼티, 메서드)설정 가능하다.
private으로 설정하면 클래스 외부에서 접근할 수 없다.
자바스크립트에서 private지원하지 않아 오랜동안 프로퍼티나 메서드 이름앞에 _를 붙여서 표현했다.

--------------------------------------------------------------------------------------------------------------------------------
part 8. Bundler

parcel webpack(많이 사용)

*번들러의 개념 - html, css ,자바로 코딩하기에는 비효율적인 부분이 있다. 그래서 번들러의 도움을 받는다.
대신에 웹에서 동작하지 않으니까 번들러안에 패키지를 통해서 변환을 해서 사용한다.

parcel bundler - 구성없는 단순한 자동 번들링 , 소/중형 프로젝트에 적합 - 세팅값을 추가한다거나 하지 않고 단순하게 파슬번들러에서 자동으로 동작하게됨
web pack - 매우 꼼꼼한 구성, 중/대형 프로젝트에 적합 - 너무 디테일해서 확인할 부분이 많아지기도 함

-----------------------------------------------------------------------------------------------------------------------------------------------
파비콘 설정 -
터미널에서 npm install -D parcel-plugin-static-files-copy - // package.json
{
	...
    "staticFiles": {
        "staticPath": "public",
        "watcherGlob": "**"
    }
}- public폴더 만들어서 - 터미널 npm run dev

-------------------------------------------------------------------------------------------------------------------------------------------
**autoprefixer - 개발자도구에서 가운데 줄이 그어져있는 display: webkit-box; , display: ms-flesbox; 잘 모르는 속성과 값...
웹표준이 권고안으로 나오기전에 ... 브라우저를 제작하는 벤더회사.. 접두사를 붙여 사용하는 .... 예전 브라우저를 사용하는 사람들.. 특정브라우저에서 동작할 수 있게 

구형브라우저에서도 최신의 css기술이 동작할 수 있도록 일종의 보험....  공급 업체 접두사(vender prefix)

가각 속성을 외워서 하기 어렵기 때문에 자동으로 적용해주는 패키지가 autoprefixer
터미널 에서 npm install -D parcel-plugin-static-files-copy - package.json파일에 
"browserslist": [
    "> 1%",
    "last 2 versions" 전세계의 점유율이 1퍼센트 이상 모든브라우저, 마지막에 두개버전까지는 지원하겠다.
  ]

가져오기 내보내기 - import, export (esm) 에크마스크립트모듈

**node.js는 esm아니라 common.js 제공, 그래서
import 대신에 require()
export 대신에 module.exports

//  가져온다 autoprefixer라는 패키지를 autoprefixer 이름으로 함수 지정
const autoprefixer = require('autoprefixer')
//  내보낸다. 
module.exports = {
  Plugin: [
     autoprefixer
  ]


짧게 변경
module.exports = {
  plugins: [
    require('autoprefixer')
  ]
}

저장 후 에러가 난다면. package.json에서 autoprefixer와 postcss와 충돌하는 것이니. npm i -D autoprefixer@9  -9버전으로 버전을 낮춰준다.
마지막으로 npm run dev 하면 공급업체접두사가 자동으로 붙은걸 확인 할 수 있음
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------04.20--------------
Part 8. Bundler 05.babel ~~

**babel - 자바스크립트 표준 (에크마스크립트 es..2015) 최신의 에크마 스크립트 (es6, es7, es8) 를 es5로 바벨을 이용해서 변환할 수 있다
 최신의 문법으로 작성되지만 구형의 브라우저를 사용하는 사용자들도 서비스를 쓸 수 있도록 예전의 문법으로 변환해준다. 

터미널에서 bebel 설치 -  npm i -D @babel/core @babel/preset-env - 새파일 babelrc.js 에 
module.exports = {
  plugins: [
    require('autoprefixer')
  ]
}
함수 가져오기 내보내기 후
package.json에 "browserslist": [
    "> 1%",
    "last 2 versions"
  ] 확인하기 

---------------------------------------------------------------
**커맨드 라인 인터페이스( CLI ) - 터미널에서 글자에 해당하는 명령,,,, 단어로 명령을 입력할때 cli라고 한다.
-serve 개발용 서버를 시작한다. 
-build 제품용 서버

---------------------------------------------------------------------------------------
**webpack
터미널 에서 npm i -D webpack webpack-cli webpack-dev-server@next
package.json 에서 "scripts": {
    "dev": "webpack-dev-server --mode development",
    "build": "webpack --mode production"
  },

--------------------------------------------------------------
가져오기 내보내기 -webpack.config.js 파일 만든 후
// import
const path = require('path')

// export
module.exports = {
  // 파일을 읽어들이기 시작하는 진입점 설정
  entry: './js/main.js',

  // 결과물(번들)을 반환하는 설정
  output:  {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js'
  }
}
터미널에서 npm run build 하면
dist폴더에 main.js 생김

-----------------------------------------------------------------------------------------------------------------------------
vue. js - 입문자에게 권장 react , Svelte , Angular 있음

Vue.createApp().mount('#app') - 전역객체 Vue. createApp 메소드 #app 아이디... Vue.js 문법을 해석사용할 수 있게 해준다.
ex ) HTML
<script src="http://unpkg.com/vue@next"></script>
<div id="app">
  <h1>{{ message }}</h1> - 결과적으로 hello Vue!라고 나옴
</div>

JS
Vue.createApp({
  data: function () {
    return {
      message: "Hello Vue!"
    }
  }
}).mount('#app')

갱신이 되어서 html구조에 나오게 할 수 있다, 반응성이라고 한다.

**모든 Vue 어플리케이션은 crateApp 함수를 사용하여 새로운 어플리케이션 인스턴스를 생성하여 시작한다.
const app = Vue.createApp({  })


---------------------------------------------------------------------------------------------------------------------4.21-------------------------------------------
** Vue.js 템플릿 문법

Vue.js는 렌더링 된 DOM을 컴포넌트 인스턴스의 데이터에 선언적으로 바인딩 할 수 있는 html 기반 템플릿 구문을 사용합니다.


**보간법
-문자열: 데이터 바인딩의 가장 기본 형태는 "Mustache"(이중 중괄호 구문) 기법을 사용한 문자열 보간법입니다.
 {{}} 콧수염 표현식을 사용하여 html dom에 데이터를 렌더링 한다.
<span> 메시지: {{ msg }} </span>
{{}}와 같은 Mustache 태그는 msg 속성 값으로 들어간다. 또한 msg속성이 변경될 때마다 갱신 즉 변할 수 있다. (반응성)


*영화 검색 사이트 예제
Vue3 Movie app - Vue3와 OMDb API를 사용하는 영화 검색 애플리케이션


 라우터 기술 - 특정한 사이트를 만들때 페이지 구분하기 위해 사용
https://router.vuejs.org/    
vue.js에서 제공하는 .. 시작하기 버튼

터미널에서 npm install vue-router@4 ( vue-router 4버전 설치 )
src폴더 main.js에 import router from './routes/index.js' 

Vue Instance - 인스턴스는 vue.js로 화면을 개발하기 위해 꼭 생성해야하는 필수 단위

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
** React 

**veiw를 다루는 라이브러리
**랜더링과 업데이트에 관여가 되는 라이브러리
** 컴포넌트 베이스드 개발?
**virtual DOM- 이제는 DOM을 직접 다루지 않음.

angular (앵귤러) vs React (리액트) vs Vue(뷰)
모든 기능...       간단.view업데이트에     
                          초점을 맞춘
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**component - 
내가만든 conponnet 내가 만든 이름을 prop을 값으로 지정해서 사용할 수 있다.
어떻게 보이는지 정의하고 로직을 만들어내는 일을 component를 만드는 일이다.

src, class, name, props 밖에서 넣어주는 데이터
html, css, js를 합쳐서 내가 만든 일종의 태그 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*component Based Development
만약에 웹페이지가 있다고 봤을때 version, link, content, card 이렇게 지정해서 넣는..

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSR(react client side rendering) vs SSR(react server side rendering)

CSR -js가 전부 다운로드 되어 리액트 애플리케이션이 정상 실행되기 전까지는 화면이 보이지 않음.
      -js가 전부 다운로드 되어 리액트 애플리케이션이 정상 실행된 후 화면이 보이면서 유저가 인터렉션 가능

SSR - js가 전부 다운로드 되지 않아도, 일단 화면은 보이지만 유저가 사용 할 수 없음.
      - js가 전부 다운로드 되어 리액트 애플리케이션이 정상 실행된 후 유저가 사용가능

------------------------------------------------------------------------------------------------------------------------------ 4.22 -----------------------------------------

**react 개발 환경 체크

node.js - installer, nvm(node version manager)
browser- chrome
git
vscode
-------------------------------------------------------------------------------------------------------------------------------------------------------------

**react 가 하는일 
리액트의 핵심 모듈 2개로 리액트가 하는 일 알아보기
1. 리액트 컴포넌트 => HTMLElemet 연결하기
imprt ReactDOM from 'react-dom';

2. 리액트 컴포넌트 만들기
import React from 'react';  
---------------------------------------------------------------------------------------------------------------------------------------------------

React 컴포넌트 -------->HTMLElement
만들어진 리액트 컴포넌트를 연결할때 실제 HTMLElement에 연결할때 ReactDOM 라이브러리를 이용합니다.
(js,jsx문법을 사용한 리액트컴포넌트를 html에 연결해주는 역할은 하는 것이 ReacDOM.render ( ); )

*CDN을 통해서 리액트 라이브러리 사용할 수 있다

** 내가 생성한 파일을 터미널에서 파일서버처럼 이용할 수 있는 명령어가 있다. npx serve
포트에 폴더명으로 파일서버 파일로 서빙하는 웹서버가 열린다.


------------------------------------------------------------------------  4.25  ---------------------------------------------------------------------------------------------------
**브라우저 지원

React는internet explorer9과 상위버전 포함한 모든 주요 브라우저를 지원한다. 그러나 IE9 IE10과 같은 구형 브라우저는 폴리필(polyfill) 이  필요합니다.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
**React component 만드는 법

**class 컴포넌트
import React from 'react';
//정의
class ClassComponent extends React.Component {
   render( ) {
       return (<div>Hello</div>);
   }
}
//사용
<ClassComponent />

**function 컴포넌트

//정의
 function FunctionCoponent(  {
      return<div></div>
)
// 정의 2
const FunctionComponent = () => <div>Hello</div>;
//사용
ReactDOM,render(<FunctionCopenet />, document. querySelector

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
**React.createElement로 컴포넌트 만들기

<script type="text/javascript">
console.log(React);
console.log(ReactDOM);

React.createElement (
  type, //태그 이름 문자열 | 리액트 컴포넌트 | React.Fragment
  [props], // 리액트 컴포넌트에 넣어주는 데이터 객체
  [ ... children] //자식으로 넣어주는 요소들
)

1. 태그 이름 문자열 type
ReactDOM.render(
   React.createElement("h1", null, 'type이 "태그 이름 문자열" 입니다.' )
   document.querySeletor('#root')
);

2. 리액트 컴포넌트  type
const Component = ( ) => {
   return React.createElement (
   "p",
    null,
    `type 이 "React 컴포넌트" 입니다. `
}

<Component></Component> => <Component /> => <p> type 이 "React 컴포넌트" 입니다. </p>
ReactDOM.render (
   React.createElement(Coomponent, null, null),
   document.querySelector('#root")
);


3. React.Fragment
ReactDOM.render(
    React.createElement(
         React.Fragment,
         null,
         'type 이 "React Fragment"입니다. ',
         'type 이 "React Fragment"입니다. ',
         'type 이 
     ),
    document.quertSelector("#root")
);

4. 복잡한 리액트 엘리먼트 모임
ReactDOM.render(
    React.createElement(),
    document.querySelector("#root")
)
------------------------------------------------------------------------------------------------------------------------------------------------------------
**jsx
jsx문법으로 작성된 코드는 babel로 순수한 javascript로 컴파일 하여 사용한다.
왜 JSX를 .... Reac.createElements VS JSX  가동성 좋음 / babel과 같은 컴파일 과정에서 문법적 오류를 인지하기 쉬움 

-최상위 요소가 하나여야합니다.
-최상위 요소 리턴하는 경우, ( )로 감싸야합니다.
-자식들을 바로 렌더링하고 싶으면, <>자식들</>를 사용합니다. =>Fragment
-자바스크립트 표현식을 사용하려면, {표현식}을 이용합니다.
-if문은 사용할 수 없습니다.(삼항 연산자 혹은 &&를 사용)
-style을 이용해 인라인 스티일링 가능합니다.
-class대신 className 을 사용해 class를 적용할 수 있습니다.
자식요소가 있으면, 꼭 닫아야 하고, 자식요소가 없으면 열면서 닫아야 한다.
  <p>어쩌구</p>
--------------------------------------------------------------------------------------------------------------------------------------------------
*Props와 State
props는 컴포넌트 외부에서 컴포넌트에게 주는 데이터입니다.
state는 컴포넌트 내부에서 변경할 수 있는 데이터입니다.
둘 다 변경이 발생하면, 랜더가 다시 일어날 수 있습니다.
--------------------------------------------------------------------------------------------------------------------------------------
**Render함수
props와 state를 바탕으로 컴포넌트를 그립니다.
그리고 props와 state가 변경되면, 컴포넌트를 다시 그립니다.
컴포넌트를 그리는 방법을 기술하는 함수가 랜더함수입니다.

--------------------------------------------------------------------------------------------------------------------------
**Event Handling
HTML DOM에 클릭하면 이벤트가 발생하고, 발생하면 그에 맞는 변경이 일어나도록 해야합니다.
JSX에 이벤트를 설정할 수 있습니다.
-camilCase로만 사용할 수 있습니다. onClick, onMouseEnter
-이벤트에 연결된 자바스크립트 코드는 함수이다. 이벤트 = {함수}와 같이 쓴다.
-실제 DOM 요소들에만 사용가능하다. - 리액트 컴포넌트 사용하면, 그냥  props로 전달한다.
------------------------------------------------------------------------------------------------------------------------------
**Component lifecycle 
리액트 컴포넌트는 탄생부터 죽음까지 여러지점에서 개발자가 작업이 가능하도록 메서드를 오버라이딩 할 수 있게 해준다.
------------------------------------------------------------------------------------------------------------------------------------
**npx - npm5.2.0이상부터 함께 설치된 커맨드라인 명령어


-----------------------------------------------------------------------------------------------------------4.26 업무일지-----------------------------------------------------
**React Router - Dynamic라우팅

**React Component Styling

Style Loaders
npx create-react-app style-loaders-example
cd style-loaders-example
npm run eject (웹팩 설정을 꺼내서 설정이 어떻게 됫는지 확인하기 위해)

그러면, config폴더에  webpack.config.js파일에 설정이 되어있음
그 안에 
const cssRegex = /\.css$/;
const cssModuleRegex = /\.module\.css$/;
const sassRegex =......
{test: cssRegex,
 4가지 타입을 설정 할 수 있다. ( css , sass 등등 )
------------------------------------------------------------------------------------------------------------  4.27 업무일지 -----------------------------------------------



**삼항 연산자

const a = 1 < 2

if (a) {
  console.log('참')
} else {
  console.log('거짓')
} - 해석하면 함수 a는 1<2 가 되는게 맞냐 .. 맞으면
만약에 맞다면 콘솔에 참이라고 출력해주고
안 맞다면 거짓이라고 출력해줘! 라는 뜻 

  |||
\\// 더 간단하게 코드를 생략하는 방법
console.log(a ? '참' : '거짓')
                       1     2      3     - 3개의 항이라서 삼항 연산자 
------------------------------------------------------------------------------------------------------------------
**조건문 if else

조건문을 배우기 전에 알아야할 점
브라우저의 개발자 도구에서 콘솔에 직접적으로
Math.random( )하면, 랜덤한 함수 소수점 단위로 나타나게
Math.floor(Math.random() * 10) 랜덤한 함수 소수점 단위 빼고 정수로 나타나게. 소수점 밑에는 버림 

다른 js파일에 export default function random () {
  return Math.floor(Math.random() * 10)
}
하고 main.js파일에
import random from './getRandom'

const a = random()

if ( a===0 ) {
  console.log('a is 0')
} else if ( a === 2 ) {
  console.log('a is 2')
} else {
  console.log('rest...')
}
만약에  0이면 'a is 0 , 2이면 'a is 2' 나머지이면 'rest...'
------------------------------------------------------------------------------------------------------------------------
**위에 조건문을 똑같이 switch 조건문으로 바꾸면

switch (a) {
  case 0:
    console.log('눈눈누나는 0이야')
    break
  case 2:
    console.log('안녕나는 둘이야')
    break
  case 4:
    console.log('랄라라 4444')
    break
  default:
     console.log('rest...')
}
(일반적으로 조건문 쓸때 if문 기본적으로 쓰면된다.
어떠한 내용이 딱떨어지는 기준이 있다면 switch문이 더 적절할 수도 있다.)

-----------------------------------------------------------------------------------------------------------------------
**반복문 for
for(시작조건; 종료조건; 변화조건){};
재할당 let변수로 정의 i는 반복문할때 통상적으로 변수 i로 만든다.

for (let i = 0; i < 3; i += 1 ) {
   console.log(i)   ----- 0,1,2 나옴
}
(i는 0이다. i가 false되면 종료, i가 그 조건에 안맞으면 종료, 변수에 다가 값을 더하거나 빼거나 연산자를 넣으면서 반복되게 끔)

**위에 반복문 for의 응용 버전
const ulEl = document.querySelector('ul') - html도큐멘트에서 ul 부분을 함수ulEl에 저장한다.

for (let i = 0; i < 3; i += 1 ) {   -반복문으로 0,1,2 값이 나오는데 (위참조)
  const li  = document.createElement('li') -li로 도큐멘트에 요소추가하겠다 이름은 함수 li로 지정
  li.textContent = `list-${i + 1}` - li에 내용을추가하겠다  i로 지정한 것을..저장
  li.addEventListner('click', function(){
       console.log(li.textContent}) - 지켜보다가 클릭을 하게되면 콘솔에 입력하겠다 li에 내용 추가 한 어떤것을
  ulEl.appendChild(li)  -ulEl에 보이게 삽입하겠다 li를 출력
}

---응용버전으로 
if ( i % 2 ===0 ) {   -i를 2로 나누었을때 나머지가 0일때 그러니까 나누었을때 2.5. 1.5로 나오지 않는 정수였을때.. i가 짝수였을때!!!
li.addEventListner('click', function(){
       console.log(li.textContent}) 클릭하면 내용이 나오게 할 수도 있다.
------------------------------------------------------------------------------------------------------------------------------------
Routing 이란?
URL에 따라서 그에 상응하는 화면을 전송해주는 것을 Routing이라고 한다.

리액트에서 라우팅 기능을 구현하는 것은 쉽지 않지만 React Router는 리액트에서 비교적 쉽게 라우팅이 가능하도록 도와준다.

**리액트 라우터
 네비게이션 라이브러리이다. React Router를 사용하면 앱에서 발생하는 라우팅이 location과 history 같은 wep API 와 연동된다.

-------------------------------------------------------------------------------------4.28 업무일지 -----------------------------------------------

React custom Hooks




----------------------------------------------------------------------5.2 업무일지 -------------------------------------------
11.Redux로 상태관리하기
component - communication
컨텍스트 api활용 - 전역데이터를 어떻게 효과적으로 관리할건지

 **단일스토어를 만드는법과 리액트에서 스토어 사용하는 법
-단일 스토어!
-[만들기] 단일 스토어 사용 준비하기
  import redux  
  액션을 정의하고,
  액션을 사용하는, 리듀서를 만들고  리듀서를 합친다.
  최종 합쳐진 리듀서를 인자로, 단일 스토어를 만든다.

-[사용하기] 준비한 스토어를 리액트 컴포넌트에서 사용하기
  import react-redux
  connect 함수를 이용해서 컴포넌트에 연결 

--------------------------------------------------------------------------------------------------------------------
**리덕스의 액션이란?
액션을 사실 그냥 객체(object)
두가지 형태의 액션이 있다.
 { type: 'TEST' } // payload 없는 액션
 { type: 'TEST', params: 'hello' } //payload 있는 액션

type 만이 필수 프로퍼티이며, type은 문자열이다

---------------------------------------------------------------------------------------------------------
**리덕스의 액션 생성자란?

function 액션생성자(...args) { return 액션; }

액션을 생성하는 함수를 "액션 생성자"라고 한다.
함수를 통해 액션을 생성해서, 액션 객체를 리턴해준다.
createTest('hello');// {type: 'TEST', params:'hello' } 리턴

-------------------------------------------------------------------------------------------------------------------
**리덕스의 액션이 하는 일
-액션생성자를 통해 액션을 만들어 낸다.
-만들어낸 액션 객체를 리덕스 스토어에 보낸다
-리덕스 스토어가 액션 객체를 받으면 스토어의 상태 값이 변경된다.
-변경된 상태 값에 의해 상태를 이용하고 있는 컴포넌트가 변경된다.
-액션은 스토어에 보내는 일종의 인풋이라 생각할 수 있다.

-------------------------------------------------------------------------------------------------------------
**액션을 준비하기 위해서
액션의 타입을 정의하여 변수로 빼는 단계
-강제가 아니므로 안해도 가능하다.
-그냥 타입을 문자열로 넣으면 실수 유발 가능성 큼
-미리 정의한 변수를 사용하면, 스펠링 주의를 덜 기울여도 된다.

액션 객체를 만들어내는 함수를 만드는 단계
-하나의 액션 객체를 만들기 위해 하나의 함수를 만들어낸다.
-액션의 타입은 미리 정의한 타입 변수로부터 가져와서 사용한다.

---------------------------------------------------------------------------------------------------------------------

**리듀서 (Reducers)

*리덕스의 리듀서란?
액션을 주면, 그 액션이 적용되어 달라진(안달라질수도있다) 결과를 만들어줌
함수이다.
function 리듀서 (previousState, action) { return newState; )
액션을 받아서 스테이트를 리턴하는 구조
인자로 들어오는 previousState와 리턴되는 newState는 다른 참조를 가지도록 해야한다.
-----------------------------------------------------------------------------------------------------------------------

**createStore - 스토어를 만드는 함수

const store - createStore(리듀서);
  createStore<S>{
   reducer:Reducer<S>, 
   preloadState: S,
   enhancer?: StoreEnhancer<S>
 ): Store<S>;
--------------------------------------------------------------------------------------------------

*react-redux
-provider 컴포넌트를 제공해준다.
-connect함수를 통해 '컨테이너'를 만들어준다.
  컨테이너는 스토어의 state와 dispatch(액션)을 연결한 컴포넌트에 props로 넣어주는 역할을 한다.
  그렇다면 필요한 것?
   ㄴ 어떤 state를 어떤 props에 연결할 것인지에 대한 정의
   ㄴ 어떤 dispatch(액션)을 어떤 props에 연결할 것인지에 대한 정의
   ㄴ 그 props를 보낼 컴포넌트를 정의 

------------------------------------------------------------------------------------------------5.3 업무일지 -----------------------------------------------------------------------------------------
**React로 나의 책장 만들기 (TypeScript)

로그인, 로그아웃
/* Signin.module.css */

.signin_row {
  height: 100vh;
}

.signin_title {
  text-align: center;
  font-size: 30px;
  font-weight: bold;
  color: #642828;
  text-transform: uppercase;
  margin-top: 80px;
}

.signin_subtitle {
  text-align: center;
  font-size: 20px;
  font-weight: bold;
  text-transform: uppercase;
}

.signin_underline {
  width: 200px;
  height: 6px;
  margin-right: auto;
  margin-left: auto;
  margin-top: 20px;
  background: linear-gradient(to right, #803b32, #ddb49b);
}

.signin_contents {
  margin-top: 50px;
  background-color: #f3f7f8;
  margin-left: auto;
  margin-right: auto;
  width: 800px;
}

.signin_bg {
  width: 100%;
}

.email_title {
  font-family: Roboto;
  font-size: 12px;
  font-weight: bold;
  margin-top: 40px;
  text-align: left;
  padding-left: 40px;
}

.password_title {
  font-family: Roboto;
  font-size: 12px;
  font-weight: bold;
  margin-top: 10px;
  text-align: left;
  padding-left: 40px;
}

.required {
  color: #971931;
}

.input_area {
  padding-top: 10px;
  padding-bottom: 10px;
  padding-left: 40px;
  padding-right: 40px;
}

.input {
  width: 100%;
  border-radius: 1px;
  border-width: 1px;
  font-family: Roboto;
}

.button_area {
  text-align: center;
  padding-left: 40px;
  padding-right: 40px;
  margin-top: 20px;
}

.button {
  border-color: #28546a;
  background-color: #28546a;
  text-transform: uppercase;
  border-radius: 1px;
  border-width: 2px;
  color: white;
  width: 100%;
}

.button:hover {
  background-color: #28546a;
  color: white;
}
책 목록 보여주기
/* Layout.module.css */

.layout {
  margin-left: auto;
  margin-right: auto;
  width: 800px;
  margin-bottom: 50px;
}
책 추가하기



/* Signin.module.css */ .signin_row { height : 100vh ; } .signin_title { text-align : center; font-size : 30px ; font-weight : bold; color : #642828 ; text-transform : uppercase; margin-top : 80px ; } .signin_subtitle { text-align : center; font-size : 20px ; font-weight : bold; text-transform : uppercase; } .signin_underline { width : 200px ; height : 6px ; margin-right : auto; margin-left : auto; margin-top : 20px ; background : linear-gradient (to right, # 803 b32, #ddb49b); } .signin_contents { margin-top : 50px ; background-color : #f3f7f8 ; margin-left : auto; margin-right : auto; width : 800px ; } .signin_bg { width : 100% ; } .email_title { font-family : Roboto; font-size : 12px ; font-weight : bold; margin-top : 40px ; text-align : left; padding-left : 40px ; } .password_title { font-family : Roboto; font-size : 12px ; font-weight : bold; margin-top : 10px ; text-align : left; padding-left : 40px ; } .required { color : #971931 ; } .input_area { padding-top : 10px ; padding-bottom : 10px ; padding-left : 40px ; padding-right : 40px ; } .input { width : 100% ; border-radius : 1px ; border-width : 1px ; font-family : Roboto; } .button_area { text-align : center; padding-left : 40px ; padding-right : 40px ; margin-top : 20px ; } .button { border-color : #28546a ; background-color : #28546a ; text-transform : uppercase; border-radius : 1px ; border-width : 2px ; color : white; width : 100% ; } .button :hover { background-color : #28546a ; color : white; }

 

React + TypeScript 2

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MobX 주요특징
데코레이터를 적극 활용한다.

cra 에 데코레이터를 사용하는 법...

스토어 객체에 붙이는 데코레이터가 있고, => @observable

컴포넌트에서 사용하는 데코레이터가 있다. => @observer

TypeScript 가 Base 인 라이브러리이다

Redux 와 마찬가지로, 스토어에 필요한 부분과 리액트에 필요한 부분이 있다.

npm i mobx -D

npm i mobx-react -D

리덕스와 다르게 단일 스토어를 강제하진 않는다.​

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
프로젝트에 Decorator 설정하기

npm i customize-cra react-app-rewired -D


config-overrides.js

.....

-------------------------------------------------------------------------------------------------------------------------------------------
@obsuervabel (by mobx)
observable사용법 - 2가지 방식

observable(<value>)
  -데코레이터 없이 사용하는 방식
  -@ 없이, 함수처럼 사용해서 리턴한 객체를 사용
@observable<클래스의 프로퍼티>
  -데코레이터로 사용하는 법
  - 클래스 내부에 프로퍼티 앞에 붙여서 사용
  - 한 클래스 안에 여러개의 @observable 존재

observable 사용법 - 2가지 방식
import { observable } from 'mobx';

// array 에 사용
const list = observable([1, 2, 4]);

// boolean 에 사용
const isLogin = observable(true);

// literal 객체에 사용
const age = observable({
    age: 35
});

// 클래스의 멤버 변수에 데코레이터로 사용
class AgeStore {
    @observable
    private _age = 35;
}

const ageStore = new AgeStore();
---------------------------------------------------------------------------------------------------------------------------------
@observer (by mobx-react)

observer 사용법 - 2가지 방식
observer(<컴포넌트>);

데코레이터 없이 사용하는 방식

함수 컴포넌트에 사용

<컴포넌트 클래스> 에 @observer 달아서 처리

​클래스 컴포넌트에 사용
---------------------------------------------------------------------------------
@computed  (by mobx)
computed 란 ?
getter 에만 붙일수 있다. (setter 부르면 getter 도 실행된다.)

함수가 아니라 리액티브 하다는 것에 주목

실제 컴포넌트에서 사용하는 (게터)값들에 달아서 사용하면 최소 범위로 변경할 수 있기 때문에 유용하다.

40살이 넘었을때만 나이를 올리면 40살 이하일때는 재랜더링 대상이 아닌 것과 같은 경우

내부적으로 고도의 최적화 => 어떻게 ?

매번 재계산을 하지 않는다

계산에 사용할 observable 값이 변경되지 않으면 재실행하지 않음.

다른 computed 또는 reaction 에 의해 호출되지 않으면 재실행하지 않음.

observable 과 처리 방식의 차이로 인한 성능 이슈에 주목

observable 이 변했는데 computed 가 변하지 않을때 사용에 따른 차이


---------------------------------------------------------------------------------
**GraphQL 2021

GraphQL Server 만들기
1-1) Rest API 와 GraphQL

1-2) Apollo 를 이용해서 Node.js 서버 만들기

1-3) typeDef 와 resolver

1-4) 여러개의 데이터 조회하기

1-5) 특정 데이터 조회하기

1-6) 데이터 추가하기

1-7) 데이터 변경, 삭제하기

-------------------------------------------------------5.4
Next.js 2021 블로그 만들기
Sanity로 Blog모델 만들기

npm i @sanity/cli -g    -글로벌 버전으로 sanity 설치
sanity login      - 로그인 - 구글로 로그인 - 권한 허용
mkdir my-blog-contents     - 폴더 만들기
cd my-blog-contents         - 폴더 안으로
PS C:\Users\YoureeChoi\my-blog-contents> sanity init -  sanity 프로젝트 설정
PS C:\Users\YoureeChoi\my-blog-contents> sanity start - 시작 - 로컬호스트 주소 생성
PS C:\Users\YoureeChoi\my-blog-contents> sanity deploy - 어떤 도메인을 띄울 것이냐

mkdir nextBlog // 프로젝트 폴더 생성
cd nextBlog // 생성프로젝트로 이동
sanity init // sanity 시작
project name: { 프로젝트 이름 } // 프로젝트 이름작성

Step 3) Sanity 배포
: 서버에 배포했을 시 유지비가 들지만, Saas형태의 Sanity에서 제공하는 서비스로 Sanity에 있는 서버에 배포.

sanity deploy // 배포 명령어





1. Manual setting
1) 프로젝트폴더 생성 후 npm 프로젝트로 설정
mkdir nextBlogFront
cd nextBlogFront
npm init -y
2) next와 react 설치
npm i next react react-dom

// package.json의 script수정
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  },
2. create-next-app setting
 1) 명령어 실행
npm create-next-app next-blog-front

npx nx g @nrwl/react:component Inrolebutton --project=ui --export